// Generated by CoffeeScript 1.6.2
/*
MapList JavaScript Library v1.1.1
http://github.com/jimon93/maplist.js

Require Library
  jquery.js
  jquery.tmpl.js
  underscore.js

MIT License
*/


(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function($, global) {
    var Entries, Facade, Factory, Genres, Html, InfoWindow, List, Map, MapList, Marker, Parser, log;

    log = _.bind(console.log, console);
    Facade = (function() {
      function Facade() {}

      Facade.prototype.build = function(genreId) {
        var _base,
          _this = this;

        if (typeof (_base = this.options).beforeBuild === "function") {
          _base.beforeBuild(genreId);
        }
        return this.entries.filterdThen(genreId, function(usingEntries) {
          var _base1;

          _this.usingEntries = usingEntries;
          _this.maplist.build(_this.usingEntries);
          return typeof (_base1 = _this.options).afterBuild === "function" ? _base1.afterBuild(genreId, _this.usingEntries) : void 0;
        });
      };

      Facade.prototype.clear = function() {
        var _base, _base1;

        if (typeof (_base = this.options).beforeClear === "function") {
          _base.beforeClear();
        }
        this.maplist.clear(this.usingEntries);
        return typeof (_base1 = this.options).afterClear === "function" ? _base1.afterClear() : void 0;
      };

      Facade.prototype.rebuild = function(genreId) {
        this.clear();
        return this.build(genreId);
      };

      Facade.prototype.getMap = function() {
        return this.maplist.map;
      };

      return Facade;

    })();
    Factory = (function() {
      _.extend(Factory.prototype, Facade.prototype);

      Factory.prototype["default"] = function() {
        return {
          lat: 35,
          lng: 135,
          center: null,
          zoom: 4,
          mapTypeId: google.maps.MapTypeId.ROADMAP,
          data: [],
          mapSelector: '#map_canvas',
          listSelector: '#list',
          listTemplate: null,
          infoTemplate: null,
          listToMarkerSelector: '.open-info',
          genreAlias: 'genre',
          genreContainerSelector: '#genre',
          genreSelector: 'a',
          genreDataName: "target-genre",
          firstGenre: '__all__',
          infoOpened: null,
          beforeBuild: null,
          afterBuild: null,
          beforeClear: null,
          afterClear: null,
          doFit: true,
          fitZoomReset: false,
          toMapScroll: true,
          templateEngine: $.tmpl || _.template
        };
      };

      Factory.prototype.usingEntries = [];

      function Factory(options) {
        this["default"] = __bind(this["default"], this);
        var _this = this;

        _.bindAll(this);
        this.options = this._makeOptions(options);
        this.entries = new Entries(_.clone(this.options));
        this.maplist = new MapList(_.clone(this.options));
        this.entries.then(function() {
          return _this.rebuild(_this.options.firstGenre);
        });
      }

      Factory.prototype._makeOptions = function(options) {
        options = _.extend({}, _(this).result('default'), options);
        if (options.center == null) {
          options.center = new google.maps.LatLng(options.lat, options.lng);
        }
        return options;
      };

      return Factory;

    })();
    Entries = (function() {
      function Entries(options) {
        var parser;

        this.options = options;
        _.bindAll(this);
        parser = new Parser(_.clone(this.options));
        this.options = _.extend({
          parse: parser.parse
        }, this.options);
        this.entries = this._makeEntries();
      }

      Entries.prototype.then = function(done, fail) {
        return this.entries.then(done, fail);
      };

      Entries.prototype.filterdThen = function(genreId, done, fail) {
        var _this = this;

        return this.entries.then(function(entries) {
          return done(_this._filterdEntries(genreId, entries));
        }, function(e) {
          return fail(e);
        });
      };

      Entries.prototype._makeEntries = function() {
        var data, dfd,
          _this = this;

        dfd = new $.Deferred;
        data = this.options.data;
        if (_.isArray(data)) {
          dfd.resolve(data);
        } else if (_.isString(data)) {
          $.ajax({
            url: data
          }).done(function(data) {
            return dfd.resolve(_this.options.parse(data));
          }).fail(function() {
            return dfd.reject();
          });
        } else {
          dfd.reject();
        }
        return dfd.promise();
      };

      Entries.prototype._filterdEntries = function(genreId, entries) {
        var alias, entry, _i, _len, _results;

        if (genreId === "__all__") {
          return entries;
        } else {
          alias = this.options.genreAlias;
          _results = [];
          for (_i = 0, _len = entries.length; _i < _len; _i++) {
            entry = entries[_i];
            if (entry[alias] === genreId) {
              _results.push(entry);
            }
          }
          return _results;
        }
      };

      return Entries;

    })();
    Parser = (function() {
      function Parser(parser) {
        this.parser = parser;
        _.bindAll(this);
        if (this.parser == null) {
          this.parser = Parser.defaultParser;
        }
      }

      Parser.prototype.execute = function(data) {
        if (_.isFunction(this.parser)) {
          return this.parser(data);
        } else if (this.parser.execute != null) {
          return this.parser.execute(data);
        } else {
          throw "parser is function or on object with the execute method";
        }
      };

      Parser.defaultParser = function(data) {
        if (data instanceof Entries) {
          return data;
        } else if (data instanceof Entry) {
          return [data];
        } else if ($.isXMLDoc(data)) {
          return Parser.XMLParser.execute(data);
        } else if (_.isObject(data)) {
          return Parser.ObjectParser.execute(data);
        } else {
          throw "Illegal Argument Error";
        }
      };

      return Parser;

    })();
    Parser.XMLParser = (function() {
      XMLParser.prototype["default"] = function() {
        return {
          place: "place",
          genre: "genre"
        };
      };

      function XMLParser(options) {
        _.bindAll(this);
        this.options = _.extend({}, _(this).result('default'), options);
      }

      XMLParser.prototype.execute = function(data) {
        var $root, place, _i, _len, _ref, _results;

        $root = $(">*", data).eq(0);
        _ref = $(this.options.place).get();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          place = _ref[_i];
          _results.push(makePlace($(place)));
        }
        return _results;
      };

      XMLParser.prototype.makePlace = function($place) {
        var res;

        res = _.extend({}, this.getGenre($place), this.getContent($place), this.getAttribute($place));
        if ((res.lat == null) && (res.latitude != null)) {
          res.lat = res.latitude;
          delete res.latitude;
        }
        if ((res.lng == null) && (res.longitude != null)) {
          res.lng = res.longitude;
          delete res.longitude;
        }
        return res;
      };

      XMLParser.prototype.getGenre = function($place) {
        var $genre, attr, res, _i, _len, _ref;

        $genre = $place.closest(this.options.genre);
        res = {};
        if ($genre.size() === 1) {
          res.genre = $genre.attr("id");
          res.genreName = $genre.attr("name");
          _ref = $genre.get(0).attributes;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            attr = _ref[_i];
            if (!_(["id", "name"]).include(attr.name)) {
              res[attr.name] = attr.value;
            }
          }
        }
        return res;
      };

      XMLParser.prototype.getContent = function($place) {
        var elem, res, _i, _len, _ref;

        res = {};
        _ref = $place.children().get();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          res[elem.nodeName.toLowerCase()] = $(elem).text();
        }
        return res;
      };

      XMLParser.prototype.getAttribute = function($place) {
        var attr, res, _i, _len, _ref;

        res = {};
        _ref = $place.get(0).attributes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          attr = _ref[_i];
          if (attr !== "id" && attr !== "name") {
            res[attr.name] = attr.value;
          }
        }
        return res;
      };

      /*
        alias = @options.genreAlias
        $.map $root.find(">#{alias}"), (genre)=>
          $genre = $(genre)
          $.map $genre.find(">place"), (place)=>
            $place = $(place)
            lat = $place.attr('latitude')
            lng = $place.attr('longitude')
            return null unless lat and lng
            res = {} # reduceでやりたい
            $place.children().each (idx,elem)=>
              res[elem.nodeName] = $(elem).text()
            position = { lat: $place.attr('latitude'), lng: $place.attr('longitude') }
            return _.extend( {}, genre, position, res )
      */


      return XMLParser;

    })();
    Parser.ObjectParser = (function() {
      function ObjectParser() {}

      ObjectParser.prototype.execute = function(data) {
        return data;
      };

      return ObjectParser;

    })();
    Map = (function() {
      function Map() {}

      return Map;

    })();
    Html = (function() {
      function Html(templateEngine, template, entry) {
        this.templateEngine = templateEngine;
        this.template = template;
        this.entry = entry;
      }

      Html.prototype.makeHTML = function() {
        var res;

        if (!((this.templateEngine != null) || (this.template != null))) {
          return null;
        }
        res = this.templateEngine(this.template, this.entry);
        if (res.html != null) {
          res = res.html();
        }
        return res;
      };

      return Html;

    })();
    InfoWindow = (function(_super) {
      __extends(InfoWindow, _super);

      function InfoWindow() {
        var content,
          _this = this;

        InfoWindow.__super__.constructor.apply(this, arguments);
        content = this.makeHTML();
        if (content != null) {
          this.info = new google.maps.InfoWindow({
            content: content
          });
          google.maps.event.addListener(this.info, 'closeclick', function() {
            return InfoWindow.openedInfo = null;
          });
        } else {
          this.info = null;
        }
      }

      return InfoWindow;

    })(Html);
    Marker = (function() {
      function Marker() {}

      return Marker;

    })();
    List = (function() {
      function List() {}

      return List;

    })();
    Genres = (function() {
      function Genres() {
        $(this.options.genreContainerSelector).on("click", this.options.genreSelector, this._selectGenre);
      }

      Genres.prototype._selectGenre = function(e, genreId) {
        var $target;

        if (genreId == null) {
          $target = $(e.currentTarget);
          genreId = $target.data(this.options.genreDataName);
        }
        this.rebuild(genreId);
        return false;
      };

      return Genres;

    })();
    MapList = (function() {
      function MapList(options) {
        var canvas, mapOptions;

        this.options = options;
        _.bindAll(this);
        mapOptions = _(this.options).clone();
        canvas = $(this.options.mapSelector).get(0);
        this.map = new google.maps.Map(canvas, mapOptions);
      }

      MapList.prototype.build = function(entries) {
        var bounds, entry, info, listElem, marker, _i, _len, _ref;

        if (this.options.doFit) {
          bounds = new google.maps.LatLngBounds;
        }
        for (_i = 0, _len = entries.length; _i < _len; _i++) {
          entry = entries[_i];
          _ref = this.getEntryData(entry), info = _ref[0], marker = _ref[1], listElem = _ref[2];
          marker.setMap(this.map);
          if (this.options.doFit) {
            bounds.extend(marker.getPosition());
          }
          if (listElem != null) {
            listElem.appendTo($(this.options.listSelector));
          }
        }
        if (this.options.doFit) {
          if (!this.options.fitZoomReset) {
            return this.map.fitBounds(bounds);
          } else {
            this.map.setCenter(bounds.getCenter());
            return this.map.setZoom(this.options.zoom);
          }
        }
      };

      MapList.prototype.clear = function(entries) {
        var entry, info, listElem, marker, _i, _len, _ref, _results;

        _results = [];
        for (_i = 0, _len = entries.length; _i < _len; _i++) {
          entry = entries[_i];
          _ref = this.getEntryData(entry), info = _ref[0], marker = _ref[1], listElem = _ref[2];
          if (this.openInfo != null) {
            this.openInfo.close();
          }
          marker.setMap(null);
          _results.push(listElem != null ? listElem.detach() : void 0);
        }
        return _results;
      };

      MapList.prototype.getEntryData = function(entry) {
        var info, listElem, marker, _ref, _ref1, _ref2;

        info = (_ref = entry.__info) != null ? _ref : entry.__info = this.makeInfo(entry);
        marker = (_ref1 = entry.__marker) != null ? _ref1 : entry.__marker = this.makeMarker(entry, info);
        listElem = (_ref2 = entry.__listElem) != null ? _ref2 : entry.__listElem = this.makeListElem(entry, marker, info);
        return [info, marker, listElem];
      };

      MapList.prototype.makeInfo = function(entry) {
        var content, info,
          _this = this;

        content = this.makeHTML(this.options.infoTemplate, entry);
        if (content != null) {
          content = $(content).html();
          info = new google.maps.InfoWindow({
            content: content
          });
          google.maps.event.addListener(info, 'closeclick', function() {
            return _this.openInfo = null;
          });
          return info;
        } else {
          return null;
        }
      };

      MapList.prototype.makeMarker = function(entry, info) {
        var marker, position;

        position = new google.maps.LatLng(entry.lat, entry.lng);
        marker = new google.maps.Marker({
          position: position,
          icon: entry.icon,
          shadow: entry.shadow
        });
        if (info) {
          google.maps.event.addListener(marker, 'click', this.openInfoFunc(marker, info));
        }
        return marker;
      };

      MapList.prototype.makeListElem = function(entry, marker, info) {
        var $content, content;

        content = this.makeHTML(this.options.listTemplate, entry);
        if (content != null) {
          $content = $(content);
          $content.data(this.options.genreAlias, entry[this.options.genreAlias]);
          if (this.options.listToMarkerSelector != null) {
            $content.on("click", this.options.listToMarkerSelector, this.openInfoFunc(marker, info));
          }
          return $content;
        } else {
          return null;
        }
      };

      MapList.prototype.openInfoFunc = function(marker, info) {
        var _this = this;

        return function(e) {
          var _base;

          if (_this.openInfo != null) {
            _this.openInfo.close();
          }
          info.open(_this.map, marker);
          _this.openInfo = info;
          if (_this.options.toMapScroll) {
            _this.toMapScroll();
          }
          return typeof (_base = _this.options).infoOpened === "function" ? _base.infoOpened(marker, info) : void 0;
        };
      };

      MapList.prototype.makeHTML = function(template, entry) {
        var res;

        if (template == null) {
          return null;
        }
        res = this.options.templateEngine(template, entry);
        return $(res);
      };

      MapList.prototype.toMapScroll = function() {
        var top;

        top = $(this.options.mapSelector).offset().top;
        return $('html,body').animate({
          scrollTop: top
        }, 'fast');
      };

      return MapList;

    })();
    global.MapList = Factory;
    Factory.Entries = Entries;
    Factory.Parser = Parser;
    return Factory.MapList = MapList;
  })(jQuery, this);

}).call(this);
